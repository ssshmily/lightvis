<?xml version="1.0" encoding="UTF-8"?>
<krpano>
  <!-- Global variables used by actions and plugins -->
  <krpano
        tour_soundson="true"
        tour_soundsvolume="100"
        tour_autotourenabled="false"
        tour_autorotateenabled="false"
        tour_controlmodemousetype="drag"
        tour_controlmodetouchtype="drag"
        tour_fullscreen="false"
        tour_displaymap="false"
        tour_displaythumbnails="true"
        tour_displayfloorplan="false"
        tour_displayinfo="false"
        tour_displayspots="true"
        tour_displaycontrols="true"
        tour_language="zh" />
  <krpano tour_gyroscopedevices="true" devices="no-desktop.and.html5" />
  <krpano tour_vrdevices="true" devices="html5" />
  <krpano videos_sounds_path="%FIRSTXML%" devices="html5" />
  <krpano videos_sounds_path="%SWFPATH%" devices="flash" />
  <krpano projection_current_params="view.fisheyefovlink=0.5&amp;view.architectural=0.0&amp;view.pannini=0.0&amp;view.fisheye=0.0&amp;view.stereographic=false" />


  <display autofullscreen="false" devices="android" />


  <krpano vrtourdevice.desktop="desktop" vrtourdevice.tablet="tablet" vrtourdevice.mobile="mobile" />
  <krpano vrtourdevicescale.desktop="1.0" vrtourdevicescale.tablet="1.0" vrtourdevicescale.mobile="2.0" />
  <action name="vrtourcurrentscale" autorun="preinit">
    mul(stagescale,get(vrtourdevicescale));
  </action>

  <!-- Control Mode Management -->
  <control mouse="drag" touch="drag" />
  <action name="setControlModeDragTo">setControlMode(drag);</action>
  <action name="setControlModeMoveTo">setControlMode(moveto);</action>
  <action name="setControlMode">
    if (device.desktop,
      set(control.mouse, %1);
      set(tour_controlmodemousetype, %1);
    ,
      set(control.touch, %1);
      set(tour_controlmodetouchtype, %1);
    );
    events.dispatch(oncontrolmodechanged);
  </action>



  <!-- Tour Messages -->
  <action name="getmessage">
    txtadd(real_message_id, get(tour_language), "_", %2);
    set(%1, get(data[get(real_message_id)].content));
  </action>

  <!-- Hide / Show Hotspots -->
  <action name="hideHotspots">
    set(tour_displayspots, false);
    set(nb_spots, get(hotspot.count));
    if (nb_spots != 0, hidepanospotsaction(); );
    events.dispatch(hotspots_visibility_changed);
  </action>
  <action name="showHotspots">
    set(tour_displayspots, true);
    set(nb_spots, get(hotspot.count));
    if (nb_spots != 0, showpanospotsaction(); );
    events.dispatch(hotspots_visibility_changed);
  </action>

  <events name="hideShowHotspotsOnNewPanoEvent" onPanoStart="hideShowHotspotsOnNewPanoAction" keep="true"/>
  <action name="hideShowHotspotsOnNewPanoAction">
    set(nb_spots, get(hotspot.count));
    if (nb_spots != 0,
      if (tour_displayspots, showpanospotsaction(); , hidepanospotsaction(); );
    );
  </action>


  <action name="startbehavioursxmlcompleteaction">
    if (skipintro !== null,
      set(tour_firstlittleplanet, false);
      events.dispatch(onPanoStart);
    ,
    ifnot (tour_firststartactiondone,

      set(sceneisfull360, false);
      if (scene[get(xml.scene)].full360,
        sub(viewhfov, panoview.hmax, panoview.hmin);
        if (viewhfov == 360,
          sub(viewvfov, panoview.vmax, panoview.vmin);
          if (viewvfov == 180,
            set(sceneisfull360, true);
          );
        );
      );

      
      stoptween(view.fov);
      stoptween(view.fovmax);
      stoptween(view.hlookat);
      stoptween(view.vlookat);
      stoptween(view.fisheye);

      if (sceneisfull360 AND (device.webgl OR device.flash),
	    setlittleplanet();
      );


    ifnot (sceneisfull360,
      
      set(view.fovmax, get(panoview.fovmax));
      set(view.hlookat, get(panoview.h));
      set(view.vlookat, get(panoview.v));
      set(view.fisheye, 0.0);
      set(view.architectural, 0.0);
      set(view.stereographic, false);
      set(view.pannini, 0.0);
      set(view.fisheyefovlink, 0.5);
      set(view.fov, get(panoview.fov));

      events.dispatch(onPanoStart);
    );

    ,
      events.dispatch(onPanoStart, true);
    );
    );
  </action>

  <action name="startLittlePlanetIntroEffect">
    if(tour_firstlittleplanet,
      set(sceneisfull360, false);
      if (scene[get(xml.scene)].full360,
        sub(viewhfov, panoview.hmax, panoview.hmin);
        if (viewhfov == 360,
          sub(viewvfov, panoview.vmax, panoview.vmin);
          if (viewvfov == 180,
            set(sceneisfull360, true);
          );
        );
      );
      if (sceneisfull360,
        fromlittleplanetintrotonormalview();
      );
    );
  </action>

  <action name="setlittleplanet">
    set(view.architectural, 0.0);
    set(view.hlookat, get(panoview.h));
    set(view.vlookat, 90);
    set(view.pannini, 0.0);
    if(panoview.fovmax LE 150,
      set(view.fovmax, 150);
    ,
      set(view.fovmax, get(panoview.fovmax));
    );
    set(view.stereographic, true);
    set(view.fisheyefovlink, 1.5);
    set(view.fisheye, 1.0);
    set(view.fov, 150);

    events.dispatch(onStartLittlePlanetIntroduction);
  </action>
  <action name="fromlittleplanetintrotonormalview">
	tweennormalview();
  </action>
  <action name="tweennormalview">
    hideTooltip();
    tween(view.fovmax, get(panoview.fovmax), 3, easeoutquad);
    tween(view.hlookat,  get(panoview.h), 3, easeoutquad);
    tween(view.vlookat, get(panoview.v), 3, easeoutquad);
    if(panoview.fov LE view.fov, tween(view.fov, get(panoview.fov), 3, easeoutquad); );
    tween(view.pannini, 0.0, 3, easeoutquad);
    tween(view.fisheye, 0.0, 3, easeoutquad,
      set(view.architectural, 0.0);
      set(view.stereographic, false);
      set(view.fisheyefovlink, 0.5);

      
      events.dispatch(onEndLittlePlanetIntroduction, true);
      if (tour_firstlittleplanet,
        events.dispatch(onTourStart, true);
        set(tour_firstlittleplanet, false);
      );
      events.dispatch(onPanoStart, true);
    );
  </action>







  <events name="ptp_audio_events" devices="mobile.or.tablet.or.safari.or.chrome" keep="true"
    onTourStart="ptp_audio_start_event();"
    />
  <action name="ptp_audio_start_event" devices="mobile.or.tablet.or.safari.or.chrome">
    set(events[ptp_audio_events].onTourStart, null);
    ptp_audio_start();
  </action>
  <action name="ptp_audio_start" devices="mobile.or.tablet.or.safari.or.chrome">
    if (tour_soundson === true,
      playTourSounds();
    );
  </action>

  <events name="userGestureAutoplayEvents" devices="mobile.or.tablet.or.safari.or.chrome"
    onclick="activateAutoplayOnGesture();"
    onmouseup="activateAutoplayOnGesture();"
    onmousedown="activateAutoplayOnGesture();"
    onkeydown="activateAutoplayOnGesture()"
    onkeyup="activateAutoplayOnGesture();"
    keep="true" />

  <action name="activateAutoplayOnGesture" devices="mobile.or.tablet.or.safari.or.chrome">
    startAutoplayOnGesture();

    set(events[userGestureAutoplayEvents].onclick, null);
    set(events[userGestureAutoplayEvents].onmouseup, null);
    set(events[userGestureAutoplayEvents].onmousedown, null);
    set(events[userGestureAutoplayEvents].onkeydown, null);
    set(events[userGestureAutoplayEvents].onkeyup, null);
    set(events[userGestureAutoplayEvents].keep, false);
  </action>

  <action name="startAutoplayOnGesture" devices="mobile.or.tablet.or.safari.or.chrome">
    if(scene[get(xml.scene)].video == true,
      scene[get(xml.scene)].onstart();
    );
    set(videointerface_firstvideoscene, false);
  </action>




  <krpano panovideospotsstate="false" />
  <krpano panolivepanospotsstate="false" />
  <events name="panoVideosSpotsStateEvent" onTourStart="set(panovideospotsstate, true);set(panolivepanospotsstate, true);" keep="true" />

  <krpano ptblendmode="BLEND(1.0, easeInCubic)" />
  <action name="mainloadsceneStartup">
    loadscene(%1, get(projection_current_params), NOPREVIEW|MERGE);
  </action>
  <action name="mainloadscene">
    if (xml.scene != %1,
      events.dispatch(onleavingscene, true);

      interruptAnimation();
      resetbackgroundsoundifneeded(%1);

      set(videoscenestarttime, 0);

      for(set(scenei,0), scenei LT scene.count, inc(scenei),if(scene[get(scenei)].name == %1,

      stopdelayedcall(videointerface_videostart_call);
      if(scene[get(xml.scene)].video AND scene[%1].video == false,
        if(plugin[get(videointerface_video)],
          if(plugin[get(videointerface_video)].videourl,
            if(plugin[get(videointerface_video)].ispaused OR plugin[get(videointerface_video)].isautopaused,
              plugin[get(videointerface_video)].seek(0);
            ,
              delayedcall(videointerface_video_call, get(plugin[get(videointerface_video)].delay),

                plugin[get(videointerface_video)].stop();
              );
              set(plugin[get(videointerface_video)].delay, 0);
            );
          );

          set(plugin[get(videointerface_video)].visible, false);
      ););
      stopTourSoundsActions(true,true,true,false);
      if(tour_soundson == true AND scene[%1].video == true AND plugin[get(videointerface_video)].volume == 0,
        videointerface_change_sound();
      );
      


      if(webvr AND webvr.isenabled,
        webvr.lookat(calc(view.hlookat - panoview.h));
      );

      indexoftxt(indexsafariversion, get(device.safariversion), ".");
      subtxt(majorsafariversion, get(device.safariversion), 0, get(indexsafariversion));
      if ((device.ios AND device.iosversion GE 11) OR (device.safari AND majorsafariversion GE 11),
        loadscene(%1, get(projection_current_params), NOPREVIEW|MERGE|KEEPVIEW);
      ,
        loadscene(%1, get(projection_current_params), NOPREVIEW|MERGE|KEEPVIEW, get(ptblendmode));
      );      



      if(webvr AND webvr.isenabled,
        webvr.lookat(calc(view.hlookat + panoview.h));
      );

      ););

    ,

      for(set(scenei,0), scenei LT scene.count, inc(scenei),if(scene[get(scenei)].name == %1,
      if(scene[%1].video,plugin[get(videointerface_video)].seek(0););
      ););
    );
  </action>

  <!-- Load Previous Scene -->
  <action name="loadPreviousScene">
    copy(sceneprevnexti, scene[get(xml.scene)].index);
    dec(sceneprevnexti);
    if (sceneprevnexti LT 0, sub(sceneprevnexti, scene.count, 1););
    mainloadscene(get(scene[get(sceneprevnexti)].name));
  </action>

  <!-- Load Next Scene -->
  <action name="loadNextScene">
    copy(sceneprevnexti, scene[get(xml.scene)].index);
    inc(sceneprevnexti);
    if (sceneprevnexti GE scene.count, set(sceneprevnexti, 0););
    mainloadscene(get(scene[get(sceneprevnexti)].name));
  </action>


  <!-- AUTOROTATION -->
  <autorotate enabled="false"/>
  <krpano tour_autorotation_pausecounter="0"/>
  <krpano tour_autorotation_pauseplugin="0"/>
  <krpano tour_autorotation_openatstartplugin="0"/>
  <action name="startautorotation">
    if(tour_autorotation_pausecounter LE 0,
      set(tour_autorotateenabled, true );

      invalidatescreen();
      set(autorotate.enabled, true);
      set(tour_autorotation_pausecounter, 0);
      events.dispatch(onstartautorotation);

      if(tour_autotourenabled,
        resetautotourvariables();
      );
    );
  </action>
  <action name="stopautorotation">
    set(tour_autorotateenabled, false);
    set(autorotate.enabled, false);
    events.dispatch(onstopautorotation);

    if(tour_autotourenabled,
      stopautotourtimer();
    );
  </action>
  <action name="pauseautorotation">
    if(%1 == forceplugin,
      inc(tour_autorotation_pauseplugin);
    );
    inc(tour_autorotation_pausecounter);
    if(tour_autorotateenabled,
      set(autorotate.enabled, false);
      events.dispatch(onpauseautorotation);

      if(tour_autotourenabled AND useautotourdelay == false,
        stopautotourtimer();
      );
    );
  </action>
  <action name="resumeautorotation">
    if(%1 == forceplugin,
      if (tour_autorotation_pauseplugin GT 0,
        dec(tour_autorotation_pauseplugin);
      );
    );
    if (tour_autorotation_pausecounter GE 0,
      if(%1 != forceresume,
        if ((tour_autorotation_pausecounter GT 0) AND (tour_autorotation_pausecounter GT tour_autorotation_pauseplugin),
         dec(tour_autorotation_pausecounter);
        );
      );
    );
    if(tour_autorotateenabled,
      if(tour_autorotation_pausecounter == 0,
        if(%1 != forceresume,
          set(autorotate.enabled, true);
          events.dispatch(onresumeautorotation);

          if(tour_autotourenabled,
            resetautotourvariables();
          );
        );
      );
    ,
      if(%1 != forceresume,
        if(%1 != forceplugin,
          if(%1 != forcehotspot,
            startautorotation();
          );
        ,

          set(forceAutorotationFromPluginUnload, false);
          if(action['autorotationatstart'],
            set(forceAutorotationFromPluginUnload, true);
          );
          if(action['autotouratstart'],
            set(forceAutorotationFromPluginUnload, true);
          );
          if(forceAutorotationFromPluginUnload,
            if(tour_autorotation_openatstartplugin == 1,
              if((tour_autorotation_pauseplugin LE 0) AND (tour_autorotation_pausecounter LE 0),
                startautorotation();
              );
            );
          );
        );
      );
    );
  </action>
  <events name="autorotation_events" onnewpano="if(tour_autorotation_pauseplugin LE 0,resumeautorotation(forceresume););" ongyroscopeon="pauseautorotation(forceplugin);" ongyroscopeoff="resumeautorotation(forceplugin);" keep="true"/>


  <!-- AUTOTOUR -->

  <krpano useautotourdelay="true" autotourdelay="10" autotourHorizontalStartValue="0" />
  <action name="startautotour">
    set(tour_autotourenabled, true);
startautorotation();


    events.dispatch(onstartautotour);


  </action>
  <action name="resetautotourvariables">
    stopautotourtimer();
    delayedcall(autotour_call_id, get(autotourdelay), autotourtimer);
  </action>
  <action name="delayedcallAutotourPartial">
    sub(tempPosition, get(view.hlookat), get(autotourHorizontalStartValue));
    Math.ceil(tempPosition);
    Math.abs(tempPosition);
    if(borderCounter == 0 AND tempPosition LT previousStep,

      inc(borderCounter);
      Math.abs(firstStep, get(previousStep));
      sub(firstStepTest, get(previousStep), get(firstStep));
      set(firstStepKeep, get(firstStepTest));
      Math.abs(firstBorderSize, get(previousStep));
      add(totalPartialSize, get(firstBorderSize));
    );
    if(borderCounter GE 1,
      if(firstBorderSize != 0,
        sub(firstStepTest, get(previousStep), get(firstStep));
        Math.abs(firstStepTest, get(firstStepTest));
        if(firstStepTest LT firstStepKeep,

          add(totalPartialSize, get(firstBorderSize));
          set(firstBorderSize, 0);
        );
        set(firstStepKeep, get(firstStepTest));
      ,
        if(tempPosition LT previousStep,

          inc(borderCounter);
          Math.abs(secondBorderSize, get(previousStep));
          add(totalPartialSize, get(secondBorderSize));
        );
      );
    );
    set(previousStep, get(tempPosition));
    if(borderCounter GE 2 AND totalPartialSize GT panoramaHorizontalSize,
      delete(previousStep, panoramaHorizontalSize, totalPartialSize, firstBorderSize, secondBorderSize, firstStep, firstStepTest, firstStepKeep, borderCounter);
      autotourtimer();
    ,
      delayedcall(autotour_call_id, 0.5, delayedcallAutotourPartial);
    );
  </action>
  <action name="delayedcallAutotourFull360">
    sub(tempPosition, get(view.hlookat), get(autotourHorizontalStartValue));
    mod(tempPositionMod, get(tempPosition), 360);
    Math.ceil(tempPosition);
    Math.ceil(tempPositionMod);
    if(tempPositionMod == tempPosition,
      delayedcall(autotour_call_id, 0.5, delayedcallAutotourFull360);
    ,
      autotourtimer();
    );
  </action>
  <action name="stopautotour">
    set(tour_autotourenabled, false);
    stopautotourtimer();
stopautorotation();


    events.dispatch(onstopautotour);
  </action>
  <action name="autotourtimer">
    if(tour_autotourenabled,
      if(tour_autorotateenabled,
        if(autorotate.enabled OR useautotourdelay == true,
          stopautotour();loadNextScene();

          startautotour();
        );
      );
    );
  </action>
  <action name="stopautotourtimer">
    stopdelayedcall(autotour_call_id);
  </action>
  <events name="autotourevents" 
    onnewpano="autotouronnewpanoaction();" 
    onmouseup="autotouronuseraction(true);" 
    onmousedown="autotouronuseraction(false);" 
    onkeyup="autotouronuseraction(true);" 
    keep="true" />
  <action name="autotouronnewpanoaction">
    if(tour_autotourenabled, resetautotourvariables(););
  </action>
  <action name="autotouronuseraction">
    if(tour_autotourenabled, if(%1, resetautotourvariables();, stopautotourtimer();););
  </action>



  <krpano tour_deeplinkingvars=""/>
  <action name="computeDeepLinkingURL">
    txtadd(tour_deeplinkingvars, "s=", get(xml.scene));
    set(viewhlookat, get(view.hlookat));roundval(viewhlookat, 4);
    mod(viewhlookat, 360);
    if (viewhlookat GT 180,
      sub(viewhlookat, 360);
     ,
      if (viewhlookat LT -180, add(viewhlookat, 360));
    );
    set(viewvlookat, get(view.vlookat));roundval(viewvlookat, 4);
    set(viewfov, get(view.fov));roundval(viewfov, 4);
    txtadd(tour_deeplinkingvars, get(tour_deeplinkingvars), "&amp;h=", get(viewhlookat));
    txtadd(tour_deeplinkingvars, get(tour_deeplinkingvars), "&amp;v=", get(viewvlookat));
    txtadd(tour_deeplinkingvars, get(tour_deeplinkingvars), "&amp;f=", get(viewfov));
    if (%1 !== null,if (%1, txtadd(tour_deeplinkingvars, get(tour_deeplinkingvars), "&amp;skipintro");););
    if (%2 !== null,if (%2, txtadd(tour_deeplinkingvars, get(tour_deeplinkingvars), "&amp;norotation");););

  </action>


  <!-- Spot animation management -->
  <action name="animate">
    if (tour_stopsequence == false,
      if (stopspotsequence == false,
        txtadd(delayedname, %1, 'delay');
        if(hotspot[%1].loaded,
          inc(hotspot[%1].frame,1,get(hotspot[%1].lastframe),0);
          mul(hotspot[%1].ypos,get(hotspot[%1].frame),get(hotspot[%1].frameheight));
          txtadd(hotspot[%1].crop,'0|',get(hotspot[%1].ypos),'|',get(hotspot[%1].framewidth),'|',get(hotspot[%1].frameheight));
        );
        delayedcall(get(delayedname),%2,animate(%1,%2));
      );
    );
  </action>
  <action name="startspotanimation">
    set(tour_stopsequence, false);
    set(stopspotsequence , false);
    animate(get(name), %1);
  </action>
  <action name="stopspotanimation">
    set(hotspot[%1].stopspotsequence, true);
    txtadd(delayedname, %1, 'delay');
    stopdelayedcall(get(delayedname));
  </action>
  <action name="interruptAnimation">
    if(tour_stopsequence == false,
      set(tour_stopsequence, true);

    );
  </action>

  <!-- Disable the default fullscreen mode as it does a fullscreen only on the viewer not "on the tour" -->
  <contextmenu fullscreen="false" versioninfo="false" />

  <!-- Tooltips management -->
<!-- Tooltip Management -->

<krpano tooltipCurrentTextfieldLayer="panotourTooltipDefaultText" coretooltipmess=""/>



<action name="hideTooltip">
<!-- Not required for VR -->
</action>

<action name="showPermanentTooltip">
	if (tooltip !== null,
		getmessage(currentTooltipText, get(tooltip));
		ifnot (currentTooltipText == "",
			txtadd(permanentTooltipForSpot, get(tooltip), '_permanent');
			set(activateUsePermanentTooltip, false);
			if(%1 == "std",
				if(device.desktop,
					set(activateUsePermanentTooltip, true);
				);
			,
				if(%1 == "touch",
					if(device.tablet OR device.mobile,
						set(activateUsePermanentTooltip, true);
					);
				,
					set(activateUsePermanentTooltip, true);
				);
			);
			if(activateUsePermanentTooltip,
				addhotspot(get(permanentTooltipForSpot));
				set(hotspot[get(permanentTooltipForSpot)].ath, get(hotspot[get(name)].ath));
     			set(hotspot[get(permanentTooltipForSpot)].atv, get(hotspot[get(name)].atv));
     			set(hotspot[get(permanentTooltipForSpot)].oy, calc(hotspot[get(name)].height / 2));

     			set(hotspot[get(permanentTooltipForSpot)].edge,top);
				set(hotspot[get(permanentTooltipForSpot)].type,text);
				set(hotspot[get(permanentTooltipForSpot)].bg,false);
				set(hotspot[get(permanentTooltipForSpot)].bgborder,0);
				set(hotspot[get(permanentTooltipForSpot)].txtshadow,'1.0 1.0 4.0 0x000000 1');
				set(hotspot[get(permanentTooltipForSpot)].css,'color:#ffffff;font-family:Arial;font-weight:bold;font-size:14px;text-align:center;');
				set(hotspot[get(permanentTooltipForSpot)].interactivecontent, false);
				set(hotspot[get(permanentTooltipForSpot)].zorder,3);
				set(hotspot[get(permanentTooltipForSpot)].padding,2);

				set(hotspot[get(permanentTooltipForSpot)].distorted,true);
				set(hotspot[get(permanentTooltipForSpot)].depth,1000);
				set(hotspot[get(permanentTooltipForSpot)].tag,"tooltip");

				set(hotspot[get(permanentTooltipForSpot)].enabled,false);
				set(hotspot[get(permanentTooltipForSpot)].capture,false);
				set(hotspot[get(permanentTooltipForSpot)].visible, true);

				set(tooltipHtmlText, get(currentTooltipText));
				escape(tooltipHtmlText);
				set(hotspot[get(permanentTooltipForSpot)].html, get(tooltipHtmlText));
			);
		);
	);
</action>

<action name="updatePermanentTooltip">
	for(set(hsi, 0), hsi LT hotspot.count, inc(hsi),
		if(hotspot[get(hsi)].tooltip !== NULL AND hotspot[get(hsi)].tooltip != "",
			txtadd(permTooltipName, get(hotspot[get(hsi)].tooltip), '_permanent');
			if(permTooltipName,
				getmessage(changeTooltipTxt, get(hotspot[get(hsi)].tooltip));
				escape(changeTooltipTxt);
				set(hotspot[get(permTooltipName)].html, get(changeTooltipTxt));
			);
		);
	);
</action>

<events name="permanentTooltipEvents" keep="true" changetourlanguage="updatePermanentTooltip()" />



<!-- Default HTML5 tooltip style -->

<hotspot name="panotourTooltipDefaultText"
	keep="true"
	enabled="false"
	capture="false"
	type="text"
	align="center"
	bg="false"
	bgborder="0"
	txtshadow="1.0 1.0 4.0 0x000000 1"
	css="color:#ffffff;font-family:Arial;font-weight:bold;font-size:14px;text-align:left;"
	edge="top"
	zorder="4"
	distorted="true"
	depth="1000"
	renderer="webgl"
	oversampling="1.0"
	mipmapping="false"
	interactivecontent="false"
	wordwrap="true"
	padding="2"
	visible="false"
	html=""
/>



<!-- Panoramic video player interface -->

<krpano videointerface_seekbar_update="" videointerface_controlbar_update="" videointerface_firstvideoscene="true" />


<krpano videointerface_vrfirstscene="true" />

<events name="videointerface_vrstart_events" keep="true"
	onnewpano="videointerface_auto_pause_vr_init();"
	onTourStart="videointerface_auto_play_vr_init();"
	/>

<action name="videointerface_auto_pause_vr_init">
	if(videointerface_vrfirstscene == true,
		if(scene[get(xml.scene)].video == true,
			if(plugin[WebVR],if(plugin[WebVR].isenabled == false,
				if(plugin[get(videointerface_video)],if(plugin[get(videointerface_video)].ispaused == false,
					plugin[get(videointerface_video)].pause();
				,
					delayedcall(delay_vrfirstscene, 0.2, videointerface_auto_pause_vr_init());
				););
			););
		);
	);
</action>

<action name="videointerface_auto_play_vr_init">
	stopdelayedcall(delay_vrfirstscene);
	set(videointerface_vrfirstscene, false);

	if(scene[get(xml.scene)].video == true,
		if(plugin[WebVR],if(plugin[WebVR].isenabled,
			if(plugin[get(videointerface_video)],if(plugin[get(videointerface_video)].ispaused == true,
				if(videoscenestarttime GT 0,
	            	plugin[get(videointerface_video)].seek(videoscenestarttime);
	            	set(videoscenestarttime, 0);
	            );
				plugin[get(videointerface_video)].play();
			););
		););
	);
</action>

<events name="videointerface_start_events" devices="mobile.or.tablet" keep="true"
	onmousedown="videointerface_auto_start();"
	onvideointerfaceinit="videointerface_auto_start_init();"
	/>


<action name="videointerface_auto_start_init">
	set(events[videointerface_start_events].onmousedown, null);
</action>


<action name="videointerface_auto_start">
	if(videointerface_autostart !== true,
		ifnot(scene[get(xml.scene)].video,
			if(plugin[get(videointerface_video)],
			if(plugin[get(videointerface_video)].ispaused,
				plugin[get(videointerface_video)].play();
				delayedcall(0.1, plugin[get(videointerface_video)].pause(););
				set(videointerface_autostart, true);
				events.dispatch(onvideointerfaceinit);
			););
		);
	);
</action>


<plugin name="ptvideosceneplayer"
	url.flash="%SWFPATH%/graphics/videoplayer.swf"
	url.html5="%FIRSTXML%/graphics/videoplayer.js"
	width.no-panovideosupport.or.html5.and.ie.and.mobile="100%"
	height.no-panovideosupport.or.html5.and.ie.and.mobile="prop"
	onloaded="videointerface_setup_interface(get(name));"
	onvideoready="videointerface_videoready();"

videourl="%FIRSTXML%/pano_19942/tingyuan.mp4"
posterurl="%FIRSTXML%/pano_19942/frame.jpg"
	autoresume="true"
	preferredformat.chrome="mp4"
	preferredformat.firefox="webm"
	preferredformat.safari="mp4"
	preferredformat.ie="mp4"
	preferredformat.edge="mp4"
	buffertime="0.1"
	volume="1.0"
	pausedonstart="true"
	loop="false"
	onvideocomplete=""
	enabled="false"
	zorder="0"
	visible="false"
	panovideo="false"
	align="center"
	ox="0"
	oy="0"
	keep="true"
	delay="0"
	mute="false"
	splashscreen="false"
	/>


<events name="videointerface_events"
	onremovepano="if(scene[get(xml.scene)].video == true,videointerface_close(););"
	videointerfaceready="videointerface_open();"
	videointerfaceactivated="videointerface_update_pausestate();"
	changetoursoundsevent="videointerface_change_sound();"
	stoptoursoundsevent="videointerface_stop_sound();"
	playtoursoundsevent="videointerface_start_sound();"
	onplayvideointerface="videointerface_close_splashscreen();"
	keep="true" />

<action name="dispatch_video_start">
	if(plugin[get(videointerface_video)].isvideoready,
		videointerface_togglepause();
		videointerface_close_splashscreen(true);
	);
</action>


<action name="videointerface_change_sound">
	ifnot(plugin[get(videointerface_video)].mute,
		ifnot(device.ios,
			div(volume, tour_soundsvolume, 100);
			set(plugin[get(videointerface_video)].volume, get(volume));
		,
			if(tour_soundsvolume GT 0,
				set(plugin[get(videointerface_video)].muted, false);
			,
				set(plugin[get(videointerface_video)].muted, true);
			);
		);
	);
</action>
<action name="videointerface_start_sound">
	ifnot(plugin[get(videointerface_video)].mute,
		if (tour_soundson,
			ifnot(device.ios,
				div(volume, tour_soundsvolume, 100);
				set(plugin[get(videointerface_video)].volume, get(volume));
			,
				if(tour_soundsvolume GT 0,
					set(plugin[get(videointerface_video)].muted, false);
				,
					set(plugin[get(videointerface_video)].muted, true);
				);
			);
		,
			ifnot(device.ios,
				set(plugin[get(videointerface_video)].volume, 0);
			,
				set(plugin[get(videointerface_video)].muted, true);
			);
		);
	);
</action>
<action name="videointerface_stop_sound">
	ifnot(plugin[get(videointerface_video)].mute,
		ifnot(device.ios,
			set(plugin[get(videointerface_video)].volume, 0);
		,
			set(plugin[get(videointerface_video)].muted, true);
		);
	);
</action>


<action name="videointerface_setup_interface">
	set(videointerface_video, %1);


	if(device.panovideosupport == false OR (device.html5 AND device.ie AND device.mobile),
		set(plugin[get(videointerface_video)].panovideo, false);
	,
		set(plugin[get(videointerface_video)].panovideo, true);
	);




	ifnot(plugin[get(videointerface_video)].mute,
		ifnot(device.ios,
			div(plugin[get(videointerface_video)].volume, tour_soundsvolume, 100);
		,
			if(tour_soundsvolume GT 0,
				set(plugin[get(videointerface_video)].muted, false);
			,
				set(plugin[get(videointerface_video)].muted, true);
			);
		);
	);


	set(plugin[get(videointerface_video)].onvideoplay, videointerface_update_pausestate() );
	set(plugin[get(videointerface_video)].onvideopaused, videointerface_update_pausestate() );

	set(plugin[get(videointerface_video)].issetup, true);
</action>


<action name="videointerface_videoready">

	events.dispatch(videointerfaceready);
</action>


<action name="videointerface_togglepause">
	plugin[get(videointerface_video)].togglepause();
</action>


<action name="videointerface_play">
	if(videoscenestarttime GT 0,
		plugin[get(videointerface_video)].seek(videoscenestarttime);
	    set(videoscenestarttime, 0);
	);
	plugin[get(videointerface_video)].play();
</action>
<action name="videointerface_stop">
	plugin[get(videointerface_video)].stop();
</action>
<action name="videointerface_resume">
	plugin[get(videointerface_video)].play();
</action>
<action name="videointerface_pause">
	plugin[get(videointerface_video)].pause();
</action>
<action name="videointerface_seek">
	plugin[get(videointerface_video)].seek(%1);
</action>


<action name="videointerface_update_pausestate">
	if(plugin[get(videointerface_video)].ispaused,
		events.dispatch(onpausevideointerface);
	,
		events.dispatch(onplayvideointerface);
	);
</action>


<action name="videointerface_open">
	events.dispatch(openvideointerface);

	videointerface_update_timer();

	videointerface_open_splashscreen();
</action>
<action name="videointerface_close">
	events.dispatch(closevideointerface);

	videointerface_close_splashscreen();
	stopdelayedcall(videointerface_timeupdate);
</action>


<action name="videointerface_open_splashscreen">

	if(plugin[get(videointerface_video)].splashscreen OR %1 == true,
		set(hotspot[videointerface_splashscreen_image].visible, true);
		tween(hotspot[videointerface_splashscreen_image].alpha, 1.0, 0.25, default);
	);
	set(plugin[get(videointerface_video)].splashscreen, true);
</action>
<action name="videointerface_close_splashscreen">
	if(%1 === true,
		set(hotspot[videointerface_splashscreen_image].alpha, 0);
		set(hotspot[videointerface_splashscreen_image].visible, false);
	,
		tween(hotspot[videointerface_splashscreen_image].alpha, 0.0, 0.25, default,set(hotspot[videointerface_splashscreen_image].visible,false););
	);
	set(plugin[get(videointerface_video)].splashscreen, false);
</action>


<!-- video interface splashscreen for play-pause -->
<hotspot name="videointerface_splashscreen_image"
	url="%FIRSTXML%/graphics/videoplayer_play_button.png"
	visible="false"
	alpha="0.0"
	align="center"
	width="100"
	height="100"
	zorder="98"
	scale="0.8"
	keep="true"
	ath="0"
	atv="0"
	distorted="true"
	onclick="if(plugin[get(videointerface_video)].isvideoready, videointerface_togglepause();videointerface_close_splashscreen(););"
	/>


<action name="videointerface_update_timer">

	set(videointerface_update_timer_loop, true);
	if(videointerface_seekbar_update OR videointerface_controlbar_update,
		copy(vp, plugin[get(videointerface_video)]);
		if(vp AND vp.loaded AND vp.isvideoready AND vp.isseeking == false,
			copy(t1, vp.time);
			copy(t2, vp.totaltime);
			if(t2 GT 0, div(t3, t1, t2), set(t3,0));
			copy(l1, vp.loadedbytes);
			copy(l2, vp.totalbytes);
			if(l2 GT 0, div(l3, l1, l2), set(l3,0));
			mul(l3, 100);
			txtadd(l3_percent, get(l3), '%%');
			mul(t3, 100);
			txtadd(t3_percent, get(t3), '%%');


			if(videointerface_seekbar_update,
				txtadd(videointerface_seekbar_update_timer,get(videointerface_seekbar_update),'(',t1,',',t2,',',l3_percent,',',t3_percent,');');
				callwith(plugin[get(videointerface_video)], videointerface_seekbar_update_timer);
			);
			if(videointerface_controlbar_update,
				txtadd(videointerface_controlbar_update_timer,get(videointerface_controlbar_update),'(',t1,',',t2,',',l3_percent,',',t3_percent,');');
				callwith(plugin[get(videointerface_video)], videointerface_controlbar_update_timer);
			);
		);
		delete(vp);
	,
		set(videointerface_update_timer_loop, false);
	);


	if(videointerface_update_timer_loop == true,
		stopdelayedcall(videointerface_timeupdate);
		delayedcall(videointerface_timeupdate, 0.25, videointerface_update_timer() );
	);
</action>


<action name="videointerface_onSceneStart">
	if(videointerface_video,
		if(scene[get(xml.scene)].scenevideoloop,
			set(plugin[get(videointerface_video)].onvideocomplete, seek(0);play(););
		,
			if(scene[get(xml.scene)].scenevideoendaction == false,
				set(plugin[get(videointerface_video)].onvideocomplete, pause(););
			);
		);
		set(plugin[get(videointerface_video)].mute, get(scene[get(xml.scene)].scenevideomute));
		set(plugin[get(videointerface_video)].muted, get(scene[get(xml.scene)].scenevideomute));

	  if(scene[get(xml.scene)].scenevideomute OR tour_soundson == false,
			set(plugin[get(videointerface_video)].volume, 0.0);
		,

			if(plugin[soundinterface] AND scene[get(xml.scene)].backgroundsound,
				pausebackgroundsound();
			);
			div(videovolume, tour_soundsvolume, 100);
			copy(plugin[get(videointerface_video)].volume, videovolume);
		);
		if(scene[get(xml.scene)].scenevideopausedonstart OR ((device.android OR device.chrome OR device.safari OR device.iphone) AND videointerface_firstvideoscene),

	    videointerface_open_splashscreen(true);
		,
	    videointerface_close_splashscreen(true);
	  );
		if((device.android OR device.chrome OR device.safari OR device.iphone) AND videointerface_firstvideoscene,
			set(scene[get(xml.scene)].scenevideopausedonstart, true);
		);
		if(device.panovideosupport == false OR (device.html5 AND device.ie AND device.mobile),
	    set(plugin[get(videointerface_video)].panovideo, false);
			set(plugin[get(videointerface_video)].width, 100%);
			set(plugin[get(videointerface_video)].height, prop);
			set(plugin[get(videointerface_video)].visible,true);
		,
	    set(plugin[get(videointerface_video)].panovideo, true);
			set(plugin[get(videointerface_video)].width, '');
			set(plugin[get(videointerface_video)].height, '');
			set(plugin[get(videointerface_video)].visible, false);
		  if(scene[get(xml.scene)].planar,
			  set(image.hfov, 1.0);
			  set(image.vfov, 0.0);
			  updateobject(true, true);
			);
		);
		if(scene[get(xml.scene)].scenevideolowresurl != '' AND (device.html5 AND (device.mobile OR device.tablet OR device.safari)),
			copy(current_videoscene_url, scene[get(xml.scene)].scenevideolowresurl);
			copy(current_videoscene_posterurl, scene[get(xml.scene)].scenevideolowresposterurl);
			set(current_videoscene_quality, 'low');
		,
			copy(current_videoscene_url, scene[get(xml.scene)].scenevideourl);
			copy(current_videoscene_posterurl, scene[get(xml.scene)].scenevideoposterurl);
			set(current_videoscene_quality, 'high');
		);
		set(videoscene_url_found, false);
		txtsplit(get(current_videoscene_url), '|', arr_videoscene);
		for(set(scenevideoi,0), scenevideoi LT arr_videoscene.count, inc(scenevideoi),
			indexoftxt(indexval, get(arr_videoscene[get(scenevideoi)].value), 'indexdata/');
			if(indexval LT 0,
				txtadd(current_videoscene_url_update,'indexdata/',get(arr_videoscene[get(scenevideoi)].value));
				indexoftxt(indexval2, get(current_videoscene_url_update), get(plugin[get(videointerface_video)].videourl));
			,
				indexoftxt(indexval2, get(arr_videoscene[get(scenevideoi)].value), get(plugin[get(videointerface_video)].videourl));
			);
			if(indexval2 GE 0,
				set(videoscene_url_found, true);
			);
			delete(indexval,indexval2,current_videoscene_url_update);
		);
		ifnot(videoscene_url_found,
			if(plugin[get(videointerface_video)].issetup,
				stopdelayedcall(videointerface_video_call);
				plugin[get(videointerface_video)].playvideo(get(current_videoscene_url), get(current_videoscene_posterurl), get(scene[get(xml.scene)].scenevideopausedonstart), get(videoscenestarttime));
	      set(videoscenestarttime, 0);
				set(scene[get(xml.scene)].scenevideopausedonstart, false);

				events.dispatch(videointerfaceactivated);
			,
				delayedcall(videointerface_videostart_call, 0.2, videointerface_onSceneStart();add(plugin[get(videointerface_video)].delay, 0.2););
			);
		,
			if(plugin[get(videointerface_video)].videourl,
				if(plugin[get(videointerface_video)].isvideoready,
					stopdelayedcall(videointerface_video_call);

					events.dispatch(videointerfaceready);
					if(scene[get(xml.scene)].scenevideopausedonstart OR ((device.android OR device.chrome OR device.safari OR device.iphone) AND videointerface_firstvideoscene),
						if(videointerface_autostart !== true,
	            if(videoscenestarttime GT 0,
	              plugin[get(videointerface_video)].seek(videoscenestarttime);
	              set(videoscenestarttime, 0);
	            );
							plugin[get(videointerface_video)].play();
							delayedcall(0,plugin[get(videointerface_video)].pause(););
						,
							plugin[get(videointerface_video)].pause();
						);
						set(scene[get(xml.scene)].scenevideopausedonstart, false);
					,
	          if(videoscenestarttime GT 0,
	            plugin[get(videointerface_video)].seek(videoscenestarttime);
	            set(videoscenestarttime, 0);
	          );
						plugin[get(videointerface_video)].play();
						ifnot(tour_firststartactiondone,
							plugin[get(videointerface_video)].pause();
						);
					);
				,
					delayedcall(videointerface_videostart_call, 0.2, videointerface_onSceneStart();add(plugin[get(videointerface_video)].delay, 0.2););
				);
			);
		);
		set(videointerface_firstvideoscene, false);
		set(videointerface_autostart, true);
		events.dispatch(onvideointerfaceinit);
		delete(current_videoscene_url,current_videoscene_posterurl,videoscene_url_found,arr_videoscene);
	,
		delayedcall(videointerface_videostart_call, 0.1, videointerface_onSceneStart(););
	);
</action>




	<!-- WebVR plugin -->


	<plugin name="webvr" devices="html5" keep="true"
		url="%FIRSTXML%/graphics/webvr.js"
		onloaded="copy(webvr, plugin[webvr]);"
		mousespeed="0.00125"
		multireslock="true"
    	fullscreen_mirroring="true"
    	headtracking="true"
		friction="0.0"
		zoom="1.0"
		mobilevr_support="true"
		worldscale="1.0"
		oversampling="1.0"
		mobilevr_ipd="63.5"
		mobilevr_screensize="auto"
		mobilevr_lens_fov="96.0"
		mobilevr_lens_dist="0.60"
		mobilevr_lens_dist2="1.000|0.000|0.000|0.000"
		mobilevr_lens_ca="0.000"
		mobilevr_lens_vign="100"
		mobilevr_lens_overlap="1.0"
		mobilevr_wakelock="true"
		mobilevr_sensor_mode="3"
		mobilevr_autocalibration="false"
		mobilevr_touch_support="false"
		mobilevr_orientationlock="true"
		mobilevr_fake_support="true"
		vr_cursor="hotspot[vr_cursor]"
		vr_cursor_enabled="true"
		vr_cursor_onover="if(handcursor, tween(hotspot[vr_cursor].scale,0.4,0.1); vr_auto_click(get(vr_timeout)); );"
		vr_cursor_onout="tween(hotspot[vr_cursor].scale,0.3,0.1);"
		onavailable="webvr_onavailable();"
		onunavailable="webvr_onunavailable();"
		onunknowndevice="webvr_onunknowndevice();"
		onentervr="webvr_onentervr();webvr_portrait_mode_check(true);"
		onexitvr="webvr_onexitvr();"
		/>


	<vrheadsets>
		<headset name="cb1" caption="Cardboard 1"   fov="96.0"  dist="0.60" dist2="1|0|0|0" ca="0.000" vig="100" overlap="1.00" />
		<headset name="cb2" caption="Cardboard 2"   fov="96.0"  dist="1.00" dist2="1|0|0|0" ca="0.000" vig="100" overlap="1.10" />
		<headset name="gvr" caption="GearVR"        fov="112.0" dist="0.95" dist2="1|0|0|0" ca="0.090" vig="100" overlap="1.00" />
		<headset name="one" caption="VR ONE"        fov="109.9" dist="0.00" dist2="1.139|0.093|0.018|0.207" ca="0.090" vig="35" overlap="1.00" />
		<headset name="hom" caption="HOMiDO"        fov="101.0" dist="1.10" dist2="1|0|0|0" ca="0.075" vig="100" overlap="1.00" />
		<headset name="ccr" caption="ColorCross VR" fov="70.0"  dist="0.65" dist2="1|0|0|0" ca="0.000" vig="100" overlap="1.00" />
		<headset name="nod" caption="No Distortion" fov="96.0"  dist="0.00" dist2="1|0|0|0" ca="0.000" vig="100" overlap="1.00" />
	</vrheadsets>

	<action name="vr_tour_start">
		ifnot (tour_firststartactiondone,
			events.dispatch(onTourStart);
			set(tour_firststartactiondone, true);
		);
	</action>
	<action name="vr_video_start">
		if(scene[get(xml.scene)].video,
			dispatch_video_start();
		);
	</action>

	<hotspot name="vr_cursor" keep="true"
		url="%FIRSTXML%/graphics/webvr_cursor.png"
		crop="0|0|80|80"
		visible="false"
		enabled="false"
		distorted="true"
		scale="0.3"
		depth="1000"
		/>


	<layer name="vr_rotate_device_required" keep="true" devices="mobile"
		url="%FIRSTXML%/graphics/rotate_device.png" width="80%" height="prop"
		align="center" edge="center"
		autoalpha="true" alpha="0.0"
		enabled="false"
		/>


	<action name="vr_auto_click">
		if(webvr.isenabled,
			if(%1 != null, set(vr_aclk_timeout, %1), set(vr_aclk_timeout, 2000));
			copy(vr_aclk_t1, timertick);
			set(vr_aclk_waiting, true);
			copy(webvr.vr_aclk_hotspot, name);
			set(hotspot[vr_cursor].crop,'0|0|80|80');

			asyncloop(vr_aclk_waiting AND webvr.vr_aclk_hotspot == name,
				sub(dt, timertick,vr_aclk_t1);
				if(!hovering,
					set(vr_aclk_waiting, false);
					set(hotspot[vr_cursor].crop,'0|0|80|80');
				,
					div(f, dt, vr_aclk_timeout);
					mul(f, 16);
					roundval(f);
					Math.min(f, 16);
					mul(f, 80);
					txtadd(hotspot[vr_cursor].crop,get(f),'|0|80|80');

					sub(dt, 100);
					if(dt GT vr_aclk_timeout,
						set(vr_aclk_waiting,false);
						set(hotspot[vr_cursor].crop,'0|0|80|80');

						onclick();

						hotspot[vr_cursor].onout();
					);
				);
			);
		);
	</action>


	<events name="webvr_events" devices="html5" keep="true"
		onkeydown="if(webvr AND webvr.isenabled AND keycode==32, webvr.resetSensor(0) );"
		onmousedown="if(webvr AND webvr.isenabled, webvr_showbuttons() );"
		onresize.mobile="webvr_portrait_mode_check();"
		onexitfullscreen="vr_setup_close(false);"
		/>


	<action name="webvr_onavailable">
		if(nofullspherepanoavailable,
			webvr_onunavailable();
		,

			set(webvr.worldscale,1.0);
			webvr.loadsettings();
			set(layer[webvr_enterbutton].onclick, videointerface_auto_start();webvr.enterVR();set(visible, false); );
			set(layer[webvr_enterbutton].ondown, vr_video_start(); );
		);
	</action>


	<action name="webvr_onunknowndevice">
		if(webvr.isfake AND device.desktop AND webvr.havesettings == false,
			set(webvr.mobilevr_lens_overlap, 1.0);
			set(webvr.mobilevr_lens_fov, 96.0);
			set(webvr.mobilevr_lens_dist, 0.0);
			set(webvr.mobilevr_lens_dist2, '1|0|0|0');
			set(webvr.mobilevr_lens_ca, 0.0);
			set(webvr.mobilevr_lens_vign, 100);
		  ,
			set(webvr.ask_user_for_screensize,true);
		  );
	</action>


	<action name="webvr_onunavailable">

		delayedcall(5.0, js(accessStdVr(get(xml.scene),get(videoscenestarttime))););

		set(events[webvr_events].name, null);
		removelayer(webvr_button_text);
		removelayer(webvr_button_enter);
		removelayer(webvr_button_image);
		removelayer(webvr_enterbutton);
		removelayer(webvr_exitbutton);
		removelayer(webvr_setupbutton);
		removehotspot(vr_cursor);
		removeplugin(WebVR);
		delete(webvr);
		set(display.hotspotrenderer,'');

		addlayer(webvr_button_unavailable);
		set(layer[webvr_button_unavailable].type, 'text');
		getmessage(vr_setup_ct_message, "vr_setup_unavailable");
		set(layer[webvr_button_unavailable].html, get(vr_setup_ct_message));
		set(layer[webvr_button_unavailable].bg, false);
		set(layer[webvr_button_unavailable].align, "center");
		set(layer[webvr_button_unavailable].edge, "center");
		set(layer[webvr_button_unavailable].txtshadow, '1.0 1.0 4.0 0xd5d5d5 1.0');
		set(layer[webvr_button_unavailable].onclick, js(accessStdVr(get(xml.scene),get(videoscenestarttime))););
		set(layer[webvr_button_unavailable].onloaded, if(device.mobile,set(css, 'color:#ffffff;font-size:24px;font-family:Arial,Helvetica,sans-serif;font-weight:bold;text-align:center;');,set(css, 'color:#ffffff;font-size:32px;font-family:Arial,Helvetica,sans-serif;font-weight:bold;text-align:center;')));"
	</action>

	<action name="webvr_onentervr">

        if(device.mobile OR device.tablet OR device.safari OR device.chrome,
			ptp_audio_start();
		);

		vr_tour_start();

		set(layer[webvr_enterbutton].visible, false);


		if(webvr.ismobilevr == true AND !webvr.isfake AND webvr.ask_user_for_screensize == true AND webvr.mobilevr_screensize == 'auto',
			set(webvr.ask_user_for_screensize, false);
			vr_setup_advanced();
		);
	</action>

	<action name="webvr_onexitvr">
		stopdelayedcall(vr_button_fadeout);
		set(layer[webvr_enterbutton].visible,true);
		set(layer[webvr_exitbutton].alpha,0);
		set(layer[webvr_setupbutton].alpha,0);
		set(layer[vr_rotate_device_required].alpha,0);


		js(accessStdVr(get(xml.scene),get(videoscenestarttime)));
	</action>


	<action name="webvr_portrait_mode_check">
		if(device.mobile AND webvr.isenabled,
			div(aspect, stagewidth, stageheight);
			if(aspect != lastaspect OR '%1' == 'true',
				copy(lastaspect, aspect);
				if(stagewidth GT stageheight,

					set(display.stereo, true);
					set(webvr.mobilevr_sensor_mode, 3);
					webvr.update();
					tween(layer[vr_rotate_device_required].alpha, 0.0, 0.0);
				,

					set(display.stereo, false);
					set(webvr.mobilevr_sensor_mode, 1);
					webvr.update();
					tween(layer[vr_rotate_device_required].alpha, 1.0);
					delayedcall(3.0, tween(layer[vr_rotate_device_required].alpha, 0.0, 1.0););
				);
			);
		,
			set(lastaspect, 0);
		);
	</action>


	<layer name="webvr_enterbutton" keep="true" vr="false"
		type="container" width="100%" height="100%" align="topleft"
		bgcolor="0xffffff"
		bgalpha="0.5"
		bgborder="0"
		bgroundedge="0"
		bgshadow=""
		bgcapture="true" enabled="true"
		>

		<layer name="webvr_button_text"
			type="text"
			html=""
			bg="false"
			align="center"
			edge="bottom"
			y="-100"
			txtshadow="1.0 1.0 4.0 0xd5d5d5 1.0"
			enabled="false"
			onloaded="getmessage(html, 'project_title');if(device.mobile,set(css, 'color:#ffffff;font-size:24px;font-family:Arial,Helvetica,sans-serif;font-weight:bold;');,set(css, 'color:#ffffff;font-size:32px;font-family:Arial,Helvetica,sans-serif;font-weight:bold;'));"
			/>

		<layer name="webvr_button_enter"
			align="center" url="%FIRSTXML%/graphics/webvr_toggle.png" crop="0|0|100|63"
			width="100" height="63"
			alpha="1"
			y="-40"
			enabled="false" />

		<layer name="webvr_button_image"
			align="center" url="%FIRSTXML%/thumbnail.jpg"
			y="20" edge="top"
			width="240" height="120"
			alpha="0.8"
			enabled="false" />
	</layer>

	<layer name="webvr_exitbutton" keep="true"
		url="%FIRSTXML%/graphics/webvr_toggle.png" crop="0|63|100|63" width="100" height="63"
		onclick="webvr.exitVR();"
		align="top" y="24"
		alpha="0"
		/>

	<layer name="webvr_setupbutton" keep="true"
		url="%FIRSTXML%/graphics/webvr_settings.png" width="64" height="64"
		onclick="vr_setup_simple();"
		alpha="0"
		align="bottom" y="24"
		/>

	<action name="webvr_showbuttons">
		stopdelayedcall(vr_button_fadeout);
		if(webvr.ismobilevr,
			tween(layer[webvr_exitbutton].alpha|layer[webvr_setupbutton].alpha, 1.0|1.0, 0.25);
		,
			tween(layer[webvr_exitbutton].alpha, 1.0, 0.25);
		);
		delayedcall(vr_button_fadeout,3,
			tween(layer[webvr_exitbutton].alpha|layer[webvr_setupbutton].alpha, 0.0|0.0, 1.0);
		);
	</action>

	<!-- WebVR plugin setup -->
	<action name="vr_setup">
		vr_setup_close(false);

		if(webvr.vrsetup === null, def(webvr.vrsetup, object); );
		copy(vrs, webvr.vrsetup);

		set(webvr.vr_cursor_enabled, false);

		tween(layer[webvr_exitbutton].alpha,0);
		tween(layer[webvr_setupbutton].alpha,0);

		addlayer(vr_setup_bg);
		set(layer[vr_setup_bg].type, container);
		set(layer[vr_setup_bg].bgcolor, 0x000000);
		set(layer[vr_setup_bg].bgalpha, 0.5);
		set(layer[vr_setup_bg].bgcapture, true);
		set(layer[vr_setup_bg].handcursor, false);
		set(layer[vr_setup_bg].align, lefttop);
		set(layer[vr_setup_bg].width, 100%);
		set(layer[vr_setup_bg].height, 100%);
		set(layer[vr_setup_bg].zorder, 99999);


		copy(i_screensize, webvr.mobilevr_screensize);
		if(i_screensize == 'auto', copy(i_screensize, webvr.devicesize));
		if(i_screensize LE 0, set(i_screensize, 5.0));
		roundval(i_screensize, 1);
		txtadd(i_screensize, ' inch');

		copy(i_ipd, webvr.mobilevr_ipd);
		roundval(i_ipd, 1);
		txtadd(i_ipd, ' mm');

		copy(i_fov, webvr.mobilevr_lens_fov);
		roundval(i_fov, 1);

		copy(i_dist, webvr.mobilevr_lens_dist);
		roundval(i_dist, 2);

		copy(i_dist2, webvr.mobilevr_lens_dist2);
		txtsplit(i_dist2, '|', vrs.i_dist2_k1, vrs.i_dist2_k2, vrs.i_dist2_k3, vrs.i_dist2_k4);
		mul(vrs.i_dist2_k1,1);
		mul(vrs.i_dist2_k2,10);
		mul(vrs.i_dist2_k3,10);
		mul(vrs.i_dist2_k4,10);
		roundval(vrs.i_dist2_k1,3);
		roundval(vrs.i_dist2_k2,3);
		roundval(vrs.i_dist2_k3,3);
		roundval(vrs.i_dist2_k4,3);

		copy(i_vig, webvr.mobilevr_lens_vign);
		roundval(i_vig, 0);

		copy(i_overlap, webvr.mobilevr_lens_overlap);
		roundval(i_overlap, 2);

		copy(i_ca, webvr.mobilevr_lens_ca);
		roundval(i_ca, 3);

		set(i_headset, 'Custom');

		for(set(vrheadi,0), vrheadi LT vrheadsets.headset.count, inc(vrheadi),
			copy(hs, vrheadsets.headset[get(vrheadi)]);
			if(i_fov == hs.fov AND i_dist == hs.dist AND i_vig == hs.vig AND i_overlap == hs.overlap AND i_dist2 == hs.dist2 AND i_ca == hs.ca,
				copy(i_headset, hs.caption);
			);
		);


		set(known_size, true);
		set(sizcol, #FFFFFF);
		copy(i_devicename, webvr.devicename);
		if(i_devicename == 'Unknown',
			if(webvr.mobilevr_screensize == 'auto',
				set(sizcol, #AA0000);
				set(known_size, false);
			,
				set(i_devicename, 'Custom');
			);
		);
	</action>

	<action name="vr_setup_simple">
		vr_setup();
		copy(vrs, webvr.vrsetup);

		set(layer[vr_setup_m1].visible, false);
		set(layer[vr_setup_m2].visible, false);
		set(layer[vr_setup_m3].visible, false);

		addlayer(vr_setup_m4);
		set(layer[vr_setup_m4].type, container);
		set(layer[vr_setup_m4].parent, vr_setup_bg);
		set(layer[vr_setup_m4].align, lefttop);
		set(layer[vr_setup_m4].width, 100%);
		set(layer[vr_setup_m4].height, 100%);
		set(layer[vr_setup_m4].visible, true);

		set(vrs.vr_setup_text_parent, 'vr_setup_m4');
		vr_setup_createtext(vr_setup_hmd0, '', center, center, 0, -140, #FFFFFF, false);
		vr_setup_createimage(vr_setup_hmd4, get(i_headset), center, center, 0, -20, #FFFFFF, true, vr_setup_select('headset_simple'), , vr_setup_save());
		vr_setup_createtext(vr_setup_hmd2, get(i_headset), center, center, 0, 100, #FFFFFF, false);

		vr_setup_createtext(vr_setup_advanced, '', center, center, 0, 140, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_advanced());

		vr_setup_createbutton(vr_setup_btn1, '&#60;', left, left, 5%, 0, #FFFFFF, true, null);
		vr_setup_createbutton(vr_setup_btn2, '&#62;', right, right, 5%, 0, #FFFFFF, true, null);

		vr_setup_select('headset_simple', true);
	</action>

	<action name="vr_setup_advanced">
		vr_setup();
		copy(vrs, webvr.vrsetup);
		set(layer[vr_setup_m4].visible, false);


		addlayer(vr_setup_m1);
		set(layer[vr_setup_m1].type, container);
		set(layer[vr_setup_m1].parent, vr_setup_bg);
		set(layer[vr_setup_m1].align, lefttop);
		set(layer[vr_setup_m1].width, 100%);
		set(layer[vr_setup_m1].height, 100%);
		set(layer[vr_setup_m1].visible, true);


		addlayer(vr_setup_m3);
		set(layer[vr_setup_m3].type, container);
		set(layer[vr_setup_m3].parent, vr_setup_bg);
		set(layer[vr_setup_m3].align, lefttop);
		set(layer[vr_setup_m3].width, 100%);
		set(layer[vr_setup_m3].height, 100%);
		set(layer[vr_setup_m3].visible, false);


		addlayer(vr_setup_m2);
		set(layer[vr_setup_m2].type, container);
		set(layer[vr_setup_m2].parent, vr_setup_bg);
		set(layer[vr_setup_m2].align, lefttop);
		set(layer[vr_setup_m2].width, 100%);
		set(layer[vr_setup_m2].height, 100%);
		set(layer[vr_setup_m2].visible, false);


		set(vrs.vr_setup_text_parent, 'vr_setup_m1');
		vr_setup_createtext(vr_setup_title, '', center, center, 0, -160, #FFFFFF, false);

		vr_setup_createtext(vr_setup_dvn1, '', center, right, 0, -115, #FFFFFF, true, vr_setup_select('screen'));
		vr_setup_createtext(vr_setup_dvn2, get(i_devicename), center, left, 0, -115, get(sizcol), true, vr_setup_select('screen'));
		vr_setup_createtext(vr_setup_siz1, '', center, right, 0, -85, #FFFFFF, true, vr_setup_select('screen'));
		vr_setup_createtext(vr_setup_siz2, get(i_screensize), center, left, 0, -85, get(sizcol), true, vr_setup_select('screen'));

		vr_setup_createtext(vr_setup_ipd1, '', center, right, 0, -40, #FFFFFF, true, vr_setup_select('ipd'));
		vr_setup_createtext(vr_setup_ipd2, get(i_ipd), center, left, 0, -40, #FFFFFF, true, vr_setup_select('ipd'));

		vr_setup_createtext(vr_setup_hmd1, '', center, right, 0, +5, #FFFFFF, true, vr_setup_select('headset'));
		vr_setup_createtext(vr_setup_hmd2, get(i_headset), center, left, 0, +5, #FFFFFF, true, vr_setup_select('headset'));

		vr_setup_createtext(vr_setup_hmd3, '', center, center, 0, +35, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_customize_headset());

		if(webvr.iswebvr == false,
			vr_setup_createtext(vr_setup_cal, '', center, center, 0, +80, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_calibration());
		);

		vr_setup_createtext(vr_setup_sav   , '', center, right, -20, +125, #00AA00, true, set(bg,true), set(bg,false), vr_setup_save());
		vr_setup_createtext(vr_setup_rst   , '', center, left , +20, +125, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_reset());
		vr_setup_createtext(vr_setup_simple, '', center, right, -20, +155, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_simple());
		vr_setup_createtext(vr_setup_cls   , '', center, left , +20, +155, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_close(true));


		vr_setup_createbutton(vr_setup_btn1, '&#60;', left, left, 5%, 0, #FFFFFF, true, null);
		vr_setup_createbutton(vr_setup_btn2, '&#62;', right, right, 5%, 0, #FFFFFF, true, null);


		set(vrs.vr_setup_text_parent, 'vr_setup_m3');
		vr_setup_createtext(vr_setup_m31, '', center, center, 0, -160, #FFFFFF, false);

		vr_setup_createtext(vr_setup_fov1, '', center, right, 0, -75, #FFFFFF, true, vr_setup_select('fov'));
		vr_setup_createtext(vr_setup_fov2, get(i_fov), center, left, 0, -75, #FFFFFF, true, vr_setup_select('fov'));
		vr_setup_createtext(vr_setup_dst1, '', center, right, 0, -40, #FFFFFF, true, vr_setup_select('dist'));
		vr_setup_createtext(vr_setup_dst2, get(i_dist), center, left, 0, -40, #FFFFFF, true, vr_setup_select('dist'));
		vr_setup_createtext(vr_setup_d2tx, '', center, right, 0, -5, #FFFFFF, true, vr_setup_select('dist2k1'));
		vr_setup_createtext(vr_setup_d2k1, get(vrs.i_dist2_k1), center, left, 0, -5, #FFFFFF, true, vr_setup_select('dist2k1'));
		vr_setup_createtext(vr_setup_d2k2, get(vrs.i_dist2_k2), center, left, +100, -5, #FFFFFF, true, vr_setup_select('dist2k2'));
		vr_setup_createtext(vr_setup_d2k3, get(vrs.i_dist2_k3), center, left, +200, -5, #FFFFFF, true, vr_setup_select('dist2k3'));
		vr_setup_createtext(vr_setup_d2k4, get(vrs.i_dist2_k4), center, left, +300, -5, #FFFFFF, true, vr_setup_select('dist2k4'));

		vr_setup_createtext(vr_setup_cac1, '', center, right, 0, +30, #FFFFFF, true, vr_setup_select('ca'));
		vr_setup_createtext(vr_setup_cac2, get(i_ca), center, left, 0, +30, #FFFFFF, true, vr_setup_select('ca'));
		vr_setup_createtext(vr_setup_vig1, '', center, right, 0, +65, #FFFFFF, true, vr_setup_select('vignette'));
		vr_setup_createtext(vr_setup_vig2, get(i_vig), center, left, 0, +65, #FFFFFF, true, vr_setup_select('vignette'));
		vr_setup_createtext(vr_setup_olp1, '', center, right, 0, +100, #FFFFFF, true, vr_setup_select('overlap'));
		vr_setup_createtext(vr_setup_olp2, get(i_overlap), center, left, 0, +100, #FFFFFF, true, vr_setup_select('overlap'));

		vr_setup_createtext(vr_setup_m35, '', center, center, 0, +160, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_close_sub_menus() );


		set(vrs.vr_setup_text_parent, 'vr_setup_m2');
		vr_setup_createtext(vr_setup_cb1, '', center, center, 0, -160, #FFFFFF, false);
		vr_setup_createtext(vr_setup_cb2, '', center, center, 0, -80, #FFFFFF, false, vr_setup_select('screen'));
		vr_setup_createtext(vr_setup_cb3, '', center, center, 0, +40, #00AA00, true, set(bg,true), set(bg,false), vr_setup_do_calibration());
		vr_setup_createtext(vr_setup_cb4, '', center, center, 0, +80, #FFFFFF, true, set(bg,true), set(bg,false), webvr.resetcalibration());
		vr_setup_createtext(vr_setup_cb5, '', center, center, 0, +160, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_close_sub_menus());

		vr_setup_createtext(vr_setup_cb6, '', center, center, 0, +120, #FFFFFF, false, null);
		vr_setup_createtext(vr_setup_cb7, '', center, center, 0, +120, #00AA00, false, null);
		vr_setup_createtext(vr_setup_cb8, '', center, center, 0, +120, #AA0000, false, null);
		set(layer[vr_setup_cb6].autoalpha, true);
		set(layer[vr_setup_cb7].autoalpha, true);
		set(layer[vr_setup_cb8].autoalpha, true);
		set(layer[vr_setup_cb6].alpha, 0.0);
		set(layer[vr_setup_cb7].alpha, 0.0);
		set(layer[vr_setup_cb8].alpha, 0.0);


		if(known_size == false,
			vr_setup_select('screen', true);
		,
			vr_setup_select('ipd', true);
		);
	</action>

	<action name="vr_setup_createtext">
		addlayer(%1);
		set(layer[%1].parent, get(webvr.vrsetup.vr_setup_text_parent));
		set(layer[%1].type, 'text');
		if(device.mobile,
			set(layer[%1].css, 'color:%7;font-size:24px;font-weight:bold;font-family:Arial,Helvetica,sans-serif;');
		,
			set(layer[%1].css, 'color:%7;font-size:32px;font-weight:bold;font-family:Arial,Helvetica,sans-serif;');
		);
		set(layer[%1].padding, 0 8);
		set(layer[%1].bgroundedge, 8);
		set(layer[%1].bg, false);
		set(layer[%1].bgcolor, 0xFFFFFF);
		set(layer[%1].bgalpha, 0.25);
		set(layer[%1].align, %3);
		set(layer[%1].edge, %4);
		set(layer[%1].x, %5);
		set(layer[%1].y, %6);

		if ('%2' == '',
			getmessage(vr_setup_ct_message, %1);
			set(layer[%1].html, get(vr_setup_ct_message));
		 ,
			set(layer[%1].html, %2);
		);

		set(layer[%1].enabled, %8);
		set(layer[%1].ondown, %9);
		set(layer[%1].onup, %10);
		set(layer[%1].onclick, %11);
	</action>

	<action name="vr_setup_createbutton">
		vr_setup_createtext(%1,%2,%3,%4,%5,%6,%7,%8,%9);
		if(device.mobile,
			set(layer[%1].css, 'vertical-align:middle;text-align:center;color:%7;font-size:42px;font-weight:bold;font-family:Arial,Helvetica,sans-serif;');
			set(layer[%1].width, 54);
			set(layer[%1].height, 54);
		,
			set(layer[%1].css, 'vertical-align:middle;text-align:center;color:%7;font-size:48px;font-weight:bold;font-family:Arial,Helvetica,sans-serif;');
			set(layer[%1].width, 60);
			set(layer[%1].height, 60);
		);
		set(layer[%1].bg, true);
		set(layer[%1].padding, 0);
		set(layer[%1].bgroundedge, 8);
		set(layer[%1].vcenter, true);
	</action>

	<action name="vr_setup_createimage">
		addlayer(%1);
		set(layer[%1].parent, get(webvr.vrsetup.vr_setup_text_parent));
		set(hmd_headset, %2);
		txtreplace(hmd_headset, ' ', '');
		txtadd(imgurl, '%FIRSTXML%/graphics/', get(hmd_headset), '.png');
		set(layer[%1].url, get(imgurl));
		set(layer[%1].align, %3);
		set(layer[%1].edge, %4);
		set(layer[%1].x, %5);
		set(layer[%1].y, %6);
		set(layer[%1].width, 266);
		set(layer[%1].height, 174);
		set(layer[%1].vcenter, true);
		set(layer[%1].enabled, %8);
		set(layer[%1].ondown, %9);
		set(layer[%1].onup, %10);
		set(layer[%1].onclick, %11);
	</action>

	<action name="vr_setup_reset">

		set(webvr.mobilevr_screensize, 'auto');
		copy(i_screensize, webvr.devicesize);
		if(i_screensize LE 0, set(i_screensize, 5.0));
		roundval(i_screensize, 1);
		set(layer[vr_setup_dvn2].html, get(webvr.devicename));
		txtadd(layer[vr_setup_siz2].html, get(i_screensize), ' inch');

		set(webvr.mobilevr_ipd, 63.5);
		copy(i_ipd, webvr.mobilevr_ipd);
		roundval(i_ipd, 1);
		txtadd(layer[vr_setup_ipd2].html, get(i_ipd), ' mm');


		set(webvr.mobilevr_lens_fov, 100.0);
		set(webvr.mobilevr_lens_dist, 0.50);
		set(webvr.mobilevr_lens_dist2, 1.000|0.000|0.000|0.000);
		set(webvr.mobilevr_lens_vign, 100);
		set(webvr.mobilevr_lens_overlap, 1.00);
		set(webvr.mobilevr_lens_ca, 0.000);

		if(webvr.isfake AND device.desktop,
			vr_setup_change_headset(-1);
		,
			vr_setup_change_headset(1);
		);

		copy(vrs, webvr.vrsetup);
		vr_setup_select(get(vrs.var));
	</action>

	<action name="vr_setup_close">

		removelayer(vr_setup_bg, true);


		if(%1 == true,
			set(webvr.vr_cursor_enabled, true);
		);
	</action>

	<action name="vr_setup_save">
		webvr.saveSettings();
		vr_setup_close(true);
	</action>

	<action name="vr_setup_customize_headset">
		set(layer[vr_setup_m1].visible,false);
		set(layer[vr_setup_m2].visible,false);
		set(layer[vr_setup_m3].visible,true);

		set(layer[vr_setup_hmd1].parent, vr_setup_m3);
		set(layer[vr_setup_hmd2].parent, vr_setup_m3);
		set(layer[vr_setup_btn1].parent, vr_setup_m3);
		set(layer[vr_setup_btn2].parent, vr_setup_m3);

		set(layer[vr_setup_hmd1].y, -110);
		set(layer[vr_setup_hmd2].y, -110);

		copy(vrs, webvr.vrsetup);
		copy(vrs.old_selection, vrs.var);
		vr_setup_select('headset');
	</action>

	<action name="vr_setup_calibration">
		set(layer[vr_setup_m1].visible,false);
		set(layer[vr_setup_m2].visible,true);
	</action>

	<action name="vr_setup_close_sub_menus">
		set(layer[vr_setup_m1].visible,true);
		set(layer[vr_setup_m2].visible,false);
		set(layer[vr_setup_m3].visible,false);

		set(layer[vr_setup_hmd1].parent, vr_setup_m1);
		set(layer[vr_setup_hmd2].parent, vr_setup_m1);
		set(layer[vr_setup_btn1].parent, vr_setup_m1);
		set(layer[vr_setup_btn2].parent, vr_setup_m1);

		set(layer[vr_setup_hmd1].y, +5);
		set(layer[vr_setup_hmd2].y, +5);

		copy(vrs, webvr.vrsetup);
		if(vrs.old_selection,
			vr_setup_select(get(vrs.old_selection));
			delete(vrs.old_selection);
		);
	</action>

	<action name="vr_setup_update_dist2">
		copy(vrs, webvr.vrsetup);
		txtadd(webvr.mobilevr_lens_dist2, get(vrs.i_dist2_k1), '|', calc(vrs.i_dist2_k2/10.0), '|', calc(vrs.i_dist2_k3/10.0), '|', calc(vrs.i_dist2_k4/10.0));
		vr_setup_change_headset(0);
	</action>

	<action name="vr_setup_do_calibration">
		if(!webvr.isfake,
			tween(layer[vr_setup_cb6].alpha, 1.0, 0.1);
			tween(layer[vr_setup_cb7].alpha, 0.0, 0.1);
			tween(layer[vr_setup_cb8].alpha, 0.0, 0.1);
			webvr.calibrate(
				tween(layer[vr_setup_cb6].alpha, 0.0, 0.1);
				tween(layer[vr_setup_cb7].alpha, 1.0, 0.1);
				delayedcall(2.0, tween(layer[vr_setup_cb7].alpha, 0.0, 0.25));
			,
				tween(layer[vr_setup_cb6].alpha, 0.0, 0.1);
				tween(layer[vr_setup_cb8].alpha, 1.0, 0.1);
				delayedcall(2.0, tween(layer[vr_setup_cb8].alpha, 0.0, 0.25));
			);
		);
	</action>

	<action name="vr_setup_select">
		copy(vrs, webvr.vrsetup);

		set(layer[vr_setup_siz2].bg, false);
		set(layer[vr_setup_ipd2].bg, false);
		set(layer[vr_setup_hmd2].bg, false);
		set(layer[vr_setup_fov2].bg, false);
		set(layer[vr_setup_dst2].bg, false);
		set(layer[vr_setup_d2k1].bg, false);
		set(layer[vr_setup_d2k2].bg, false);
		set(layer[vr_setup_d2k3].bg, false);
		set(layer[vr_setup_d2k4].bg, false);
		set(layer[vr_setup_vig2].bg, false);
		set(layer[vr_setup_cac2].bg, false);
		set(layer[vr_setup_olp2].bg, false);

		set(layer[vr_setup_btn1].ondown, vr_setup_change_ondown(-1));
		set(layer[vr_setup_btn2].ondown, vr_setup_change_ondown(+1));

		set(vrs.setting, null);
		set(vrs.var, %1);
		set(vrs.var_value, null);
		set(vrs.var_callback, null);

		if(%1 == 'screen',
			set(vrs.setting, vr_setup_siz2);
			set(vrs.var_name, 'webvr.mobilevr_screensize');
			set(vrs.var_postfix, ' inch');
			copy(vrs.var_value, get(vrs.var_name));
			if(vrs.var_value == 'auto', set(vrs.var_value, 5.0));
			set(vrs.var_step, 0.1);
			set(vrs.var_min, 4);
			set(vrs.var_max, 10);
			set(vrs.var_round, 1);
			set(vrs.var_callback, vr_setup_change_screen());
		);

		if(%1 == 'ipd',
			set(vrs.setting, vr_setup_ipd2);
			set(vrs.var_name, 'webvr.mobilevr_ipd');
			set(vrs.var_postfix, ' mm');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.1);
			set(vrs.var_min, 40);
			set(vrs.var_max, 80);
			set(vrs.var_round, 1);
		);

		if(%1 == 'headset_simple',
			set(vrs.setting, vr_setup_hmd4);
			set(layer[vr_setup_btn1].ondown, vr_setup_change_headset(-1));
			set(layer[vr_setup_btn2].ondown, vr_setup_change_headset(+1));
		);

		if(%1 == 'headset',
			set(vrs.setting, vr_setup_hmd2);
			set(layer[vr_setup_btn1].ondown, vr_setup_change_headset(-1));
			set(layer[vr_setup_btn2].ondown, vr_setup_change_headset(+1));
		);

		if(%1 == 'fov',
			set(vrs.setting, vr_setup_fov2);
			set(vrs.var_name, 'webvr.mobilevr_lens_fov');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.1);
			set(vrs.var_min, 40);
			set(vrs.var_max, 179);
			set(vrs.var_round, 1);
			set(vrs.var_callback, vr_setup_change_headset(0));
		);

		if(%1 == 'dist',
			set(vrs.setting, vr_setup_dst2);
			set(vrs.var_name, 'webvr.mobilevr_lens_dist');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.01);
			set(vrs.var_min, 0);
			set(vrs.var_max, 5);
			set(vrs.var_round, 2);
			set(vrs.var_callback, vr_setup_change_headset(0));
		);

		if(%1 == 'dist2k1',
			set(vrs.setting, vr_setup_d2k1);
			set(vrs.var_name, 'webvr.vrsetup.i_dist2_k1');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.001);
			set(vrs.var_min, -9);
			set(vrs.var_max, +9);
			set(vrs.var_round, 3);
			set(vrs.var_callback, vr_setup_update_dist2());
		);

		if(%1 == 'dist2k2',
			set(vrs.setting, vr_setup_d2k2);
			set(vrs.var_name, 'webvr.vrsetup.i_dist2_k2');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.001);
			set(vrs.var_min, -9);
			set(vrs.var_max, +9);
			set(vrs.var_round, 3);
			set(vrs.var_callback, vr_setup_update_dist2());
		);

		if(%1 == 'dist2k3',
			set(vrs.setting, vr_setup_d2k3);
			set(vrs.var_name, 'webvr.vrsetup.i_dist2_k3');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.001);
			set(vrs.var_min, -9);
			set(vrs.var_max, +9);
			set(vrs.var_round, 3);
			set(vrs.var_callback, vr_setup_update_dist2());
		);

		if(%1 == 'dist2k4',
			set(vrs.setting, vr_setup_d2k4);
			set(vrs.var_name, 'webvr.vrsetup.i_dist2_k4');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.001);
			set(vrs.var_min, -9);
			set(vrs.var_max, +9);
			set(vrs.var_round, 3);
			set(vrs.var_callback, vr_setup_update_dist2());
		);

		if(%1 == 'vignette',
			set(vrs.setting, vr_setup_vig2);
			set(vrs.var_name, 'webvr.mobilevr_lens_vign');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 1);
			set(vrs.var_min, 0);
			set(vrs.var_max, 100);
			set(vrs.var_round, 0);
			set(vrs.var_callback, vr_setup_change_headset(0));
		);

		if(%1 == 'ca',
			set(vrs.setting, vr_setup_cac2);
			set(vrs.var_name, 'webvr.mobilevr_lens_ca');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.001);
			set(vrs.var_min, -1.0);
			set(vrs.var_max, +1.0);
			set(vrs.var_round, 3);
			set(vrs.var_callback, vr_setup_change_headset(0));
		);

		if(%1 == 'overlap',
			set(vrs.setting, vr_setup_olp2);
			set(vrs.var_name, 'webvr.mobilevr_lens_overlap');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.01);
			set(vrs.var_min, 0.5);
			set(vrs.var_max, 2.0);
			set(vrs.var_round, 2);
			set(vrs.var_callback, vr_setup_change_headset(0) );
		);

		if(vrs.setting != null,
			set(layer[get(vrs.setting)].bg, true);
			if(%2 == true,
				set(layer[vr_setup_btn1].y, get(layer[get(vrs.setting)].y));
				set(layer[vr_setup_btn2].y, get(layer[get(vrs.setting)].y));
			,
				tween(layer[vr_setup_btn1].y, get(layer[get(vrs.setting)].y));
				tween(layer[vr_setup_btn2].y, get(layer[get(vrs.setting)].y));
			);
		);
	</action>

	<action name="vr_setup_change_screen">
		set(layer[vr_setup_dvn2].html, 'Custom');
		if(device.mobile,
			set(layer[vr_setup_dvn2].css, 'color:#FFFFFF;font-size:24px;font-weight:bold;');
			set(layer[vr_setup_siz2].css, 'color:#FFFFFF;font-size:24px;font-weight:bold;');
		,
			set(layer[vr_setup_dvn2].css, 'color:#FFFFFF;font-size:32px;font-weight:bold;');
			set(layer[vr_setup_siz2].css, 'color:#FFFFFF;font-size:32px;font-weight:bold;');
		);
	</action>

	<action name="vr_setup_change_ondown">
		copy(t0,timertick);
		set(t1,0);
		asyncloop(pressed,
			copy(t2,timertick);
			sub(dt,t2,t1);
			if(dt GT 100,
				copy(t1,t2);
				sub(dt,t1,t0);
				div(dt,1000);
				Math.max(dt,1);
				mul(dt,%1);
				vr_setup_adjust(get(dt));
			);
		);
	</action>

	<action name="vr_setup_adjust">
		copy(vrs, webvr.vrsetup);
		if(vrs.setting != null,
			mul(change, vrs.var_step, %1);
			add(vrs.var_value, change);
			Math.max(vrs.var_value, vrs.var_min);
			Math.min(vrs.var_value, vrs.var_max);
			roundval(vrs.var_value, get(vrs.var_round));
			tween(get(vrs.var_name), get(vrs.var_value), 0.1);
			txtadd(layer[get(vrs.setting)].html, get(vrs.var_value), get(vrs.var_postfix));
			if(vrs.var_callback != null, vrs.var_callback());
		);
	</action>

	<action name="vr_setup_change_headset">
		set(i_headset, 'Custom');
		if(%1 != 0,
			copy(i_fov, webvr.mobilevr_lens_fov);
			roundval(i_fov, 1);
			copy(i_dist, webvr.mobilevr_lens_dist);
			roundval(i_dist, 2);
			copy(i_dist2, webvr.mobilevr_lens_dist2);
			copy(i_vig, webvr.mobilevr_lens_vign);
			roundval(i_vig, 0);
			copy(i_ca, webvr.mobilevr_lens_ca);
			roundval(i_ca, 3);
			copy(i_overlap, webvr.mobilevr_lens_overlap);
			roundval(i_overlap, 2);

			set(i_hsindex, -1);
			copy(i_hscount, vrheadsets.headset.count);
			for(set(vrheadj,0), vrheadj LT i_hscount, inc(vrheadj),
				copy(hs, vrheadsets.headset[get(vrheadj)]);
				if(i_fov == hs.fov AND i_dist == hs.dist AND i_vig == hs.vig AND i_overlap == hs.overlap AND i_dist2 == hs.dist2 AND i_ca == hs.ca,
					copy(i_hsindex, vrheadj);
					copy(i_headset, hs.caption);
				);
			);

			if(%1 GT 0,

				add(i_hsindex, 1);
				if(i_hsindex GE i_hscount, set(i_hsindex,0));
			,

				sub(i_hsindex, 1);
				if(i_hsindex LT 0, sub(i_hsindex,i_hscount,1));
			);

			copy(hs, vrheadsets.headset[get(i_hsindex)]);
			copy(i_headset, hs.caption);
			copy(i_fov, hs.fov);
			copy(i_dist, hs.dist);
			copy(i_dist2, hs.dist2);
			copy(i_vig, hs.vig);
			copy(i_ca, hs.ca);
			copy(i_overlap, hs.overlap);
		);

		copy(layer[vr_setup_hmd2].html, i_headset);
		txtreplace(hmd_headset, i_headset, ' ', '');
		txtadd(imgurl, '%FIRSTXML%/graphics/', get(hmd_headset), '.png');
		set(layer[vr_setup_hmd4].url, get(imgurl));
		if(%1 != 0,
			copy(webvr.mobilevr_lens_fov, i_fov);
			copy(webvr.mobilevr_lens_dist, i_dist);
			copy(webvr.mobilevr_lens_dist2, i_dist2);
			copy(webvr.mobilevr_lens_vign, i_vig);
			copy(webvr.mobilevr_lens_ca, i_ca);
			copy(webvr.mobilevr_lens_overlap, i_overlap);
			copy(layer[vr_setup_fov2].html, i_fov);
			copy(layer[vr_setup_dst2].html, i_dist);
			copy(layer[vr_setup_vig2].html, i_vig);
			copy(layer[vr_setup_olp2].html, i_overlap);
			copy(layer[vr_setup_cac2].html, i_ca);
			txtsplit(i_dist2, '|', i_dist2_k1, i_dist2_k2, i_dist2_k3, i_dist2_k4);
			mul(i_dist2_k1,1);
			mul(i_dist2_k2,10);
			mul(i_dist2_k3,10);
			mul(i_dist2_k4,10);
			roundval(i_dist2_k1,3);
			roundval(i_dist2_k2,3);
			roundval(i_dist2_k3,3);
			roundval(i_dist2_k4,3);
			copy(layer[vr_setup_d2k1].html, i_dist2_k1);
			copy(layer[vr_setup_d2k2].html, i_dist2_k2);
			copy(layer[vr_setup_d2k3].html, i_dist2_k3);
			copy(layer[vr_setup_d2k4].html, i_dist2_k4);
		);
	</action>



  <!-- Keyboard management
  * use the keyboard +/- keys to zoom in/out
  * use the keyboard CTRL+0 keys to reset the default panorama view
  -->
  <control keycodesin="107,187" keycodesout="109,189" />
  <krpano tour_ctrlPressed="false"/>
  <events name="keycontrolZoomEvents" onkeydown="onKDZ" onkeyup="onKUZ" keep="true"/>
  <action name="onKDZ">if(keycode==17,set(tour_ctrlPressed,true);,if(tour_ctrlPressed==true,if(keycode==96,hideTooltip();lookto(get(panoview.h),get(panoview.v),get(panoview.fov)););););</action>
  <action name="onKUZ">if(keycode==17,set(tour_ctrlPressed,false););</action>

  <!-- Indicate if a scene is seen or not - dispatch an event if the state is changed -->
  <events name="sceneSeenEvents" onnewpano="changeSeenState" keep="true"/>
  <krpano tour_nbseenscenes="0"/>
  <action name="changeSeenState">
    ifnot (scene[get(xml.scene)].seen,
      set(scene[get(xml.scene)].seen, true);
      events.dispatch(onSeenStateChanged);

      if (scene[get(xml.scene)].group,
        copy(currentgroup, scene[get(xml.scene)].group);
        ifnot (panoramagroup[get(currentgroup)].seen,
          set(groupseen, true);
          for( copy(sceneindex, scene[get(panoramagroup[get(currentgroup)].mainscene)].index),
               (scene[get(sceneindex)].group == currentgroup) AND groupseen,
               inc(sceneindex),
               ifnot (scene[get(sceneindex)].seen,
                 set(groupseen, false);
               );
          );
          if (groupseen,
            set(panoramagroup[get(currentgroup)].seen, true);
            events.dispatch(ongroupseenstatechanged);
          );
        );
      );

      inc(tour_nbseenscenes);
      if (tour_nbseenscenes == scene.count,
        events.dispatch(onallsceneseen);
      );
    );
  </action>


  <cursors standard="default" dragging="grab" moving="move" />



</krpano>
